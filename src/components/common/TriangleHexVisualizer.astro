import { getImage } from 'astro:assets';
import type { HTMLAttributes } from 'astro/types';

interface Props {
  width?: number;
  height?: number;
  id?: string;
  class?: string;
  alt?: string;
  style?: string;
  backgroundColor?: string;
  primaryColor?: string;
  secondaryColor?: string;
  tertiaryColor?: string;
  density?: number;
  loading?: 'eager' | 'lazy';
}

const {
  width = 1024,
  height = 576,
  id = 'triangle-hex-visualizer',
  class: className = '',
  alt = 'Triangle to Hexagon Transition Visualizer',
  style = '',
  backgroundColor = '#030b36',
  primaryColor = '#4338ca',
  secondaryColor = '#3b82f6',  
  tertiaryColor = '#06b6d4',
  density = 20,
  loading = 'lazy',
} = Astro.props;

<div 
  id={id}
  class={`relative ${className}`}
  style={`width:100%; height:${height}px; max-width:${width}px; margin:0 auto; ${style}`}
  aria-label={alt}
>
  <canvas 
    id={`${id}-canvas`}
    width={width}
    height={height}
    class="rounded-lg shadow-lg w-full"
    style="background-color: var(--background-color); width: 100%; height: 100%;"
  ></canvas>
</div>

<style define:vars={{ backgroundColor, primaryColor, secondaryColor, tertiaryColor }}>
  :root {
    --background-color: var(--backgroundColor);
    --primary-color: var(--primaryColor);
    --secondary-color: var(--secondaryColor);
    --tertiary-color: var(--tertiaryColor);
  }
</style>

<script define:vars={{ id, width, height, backgroundColor, primaryColor, secondaryColor, tertiaryColor, density }}>
document.addEventListener('DOMContentLoaded', function() {
  const canvas = document.getElementById(`${id}-canvas`);
  if (!canvas || !(canvas instanceof HTMLCanvasElement)) return;
  
  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  // Create an array to store shapes
  const shapes = [];
  
  // Animation variables
  let animationFrame;
  let lastTime = 0;
  const animationDuration = 5000; // 5 seconds for full transition
  
  class Shape {
    constructor(x, y, size) {
      this.x = x;
      this.y = y;
      this.size = size;
      this.rotation = Math.random() * Math.PI * 2;
      this.rotationSpeed = (Math.random() * 0.002) - 0.001;
      this.transitionProgress = Math.random(); // Start at random point in transition
      this.transitionSpeed = 0.0003 + (Math.random() * 0.0005);
      this.transitionDirection = Math.random() > 0.5 ? 1 : -1;
      this.color = this.getRandomColor();
    }
    
    getRandomColor() {
      const colors = [primaryColor, secondaryColor, tertiaryColor];
      return colors[Math.floor(Math.random() * colors.length)];
    }
    
    update(deltaTime) {
      // Update rotation
      this.rotation += this.rotationSpeed * deltaTime;
      
      // Update transition progress
      this.transitionProgress += this.transitionSpeed * this.transitionDirection * deltaTime;
      
      // Change direction when reaching limits
      if (this.transitionProgress >= 1) {
        this.transitionProgress = 1;
        this.transitionDirection = -1;
      } else if (this.transitionProgress <= 0) {
        this.transitionProgress = 0;
        this.transitionDirection = 1;
      }
    }
    
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);
      
      const sides = 3 + Math.floor(this.transitionProgress * 3); // 3 to 6 sides (triangle to hexagon)
      const sidesFraction = this.transitionProgress * 3 - Math.floor(this.transitionProgress * 3);
      
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.globalAlpha = 0.7; // Some transparency
      
      // Draw the shape with number of sides based on transition progress
      for (let i = 0; i < sides; i++) {
        const angle = (i * 2 * Math.PI / sides) + (Math.PI / sides);
        const x = this.size * Math.cos(angle);
        const y = this.size * Math.sin(angle);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      // If transitioning, add an additional point for smooth morphing
      if (sidesFraction > 0 && sides < 6) {
        const nextSides = sides + 1;
        const angle = ((sides - 1) * 2 * Math.PI / sides) + (Math.PI / sides);
        const nextAngle = ((sides) * 2 * Math.PI / nextSides) + (Math.PI / nextSides);
        
        const x1 = this.size * Math.cos(angle);
        const y1 = this.size * Math.sin(angle);
        
        const x2 = this.size * Math.cos(nextAngle);
        const y2 = this.size * Math.sin(nextAngle);
        
        // Interpolate between the points
        const x = x1 + (x2 - x1) * sidesFraction;
        const y = y1 + (y2 - y1) * sidesFraction;
        
        ctx.lineTo(x, y);
      }
      
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }
  
  // Initialize shapes
  function initShapes() {
    const shapesCount = density;
    for (let i = 0; i < shapesCount; i++) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      const size = 20 + Math.random() * 40;
      shapes.push(new Shape(x, y, size));
    }
  }
  
  // Animation loop
  function animate(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;
    
    // Clear canvas
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, width, height);
    
    // Update and draw shapes
    shapes.forEach(shape => {
      shape.update(deltaTime);
      shape.draw(ctx);
    });
    
    // Request next frame
    animationFrame = requestAnimationFrame(animate);
  }
  
  // Start animation
  function startAnimation() {
    if (!animationFrame) {
      lastTime = 0;
      animationFrame = requestAnimationFrame(animate);
    }
  }
  
  // Stop animation
  function stopAnimation() {
    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
      animationFrame = null;
    }
  }
  
  // Handle visibility change to save resources
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      stopAnimation();
    } else {
      startAnimation();
    }
  });
  
  // Initialize
  initShapes();
  startAnimation();
  
  // Handle resize
  window.addEventListener('resize', () => {
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
  });
});
</script> 